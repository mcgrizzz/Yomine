name: Auto Release Notes

on:
  release:
    types: [published]

permissions:
  contents: write

jobs:
  generate-release-notes:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Need full history for git-cliff
        
    - name: Determine changelog range
      id: changelog-range
      run: |
        CURRENT_TAG="${{ github.event.release.tag_name }}"
        echo "Current tag: $CURRENT_TAG"
        
        # Check if this is a beta/pre-release
        if [[ "$CURRENT_TAG" == *"beta"* ]] || [[ "$CURRENT_TAG" == *"alpha"* ]] || [[ "$CURRENT_TAG" == *"rc"* ]]; then
          echo "This is a pre-release"
          
          # For beta releases, find the previous tag (beta or stable)
          PREVIOUS_TAG=$(git tag --sort=-version:refname | grep -E "^v[0-9]+\." | grep -v "^$CURRENT_TAG$" | head -1)
          if [ -n "$PREVIOUS_TAG" ]; then
            echo "Previous tag found: $PREVIOUS_TAG"
            echo "cliff_args=$PREVIOUS_TAG..$CURRENT_TAG" >> $GITHUB_OUTPUT
            echo "range_description=Changes since $PREVIOUS_TAG" >> $GITHUB_OUTPUT
          else
            echo "No previous tag found, showing all changes"
            echo "cliff_args=--unreleased" >> $GITHUB_OUTPUT
            echo "range_description=All changes" >> $GITHUB_OUTPUT
          fi
        else
          echo "This is a stable release"
          
          # For stable releases, find the previous stable release (skip any betas)
          PREVIOUS_STABLE=$(git tag --sort=-version:refname | grep -E "^v[0-9]+\.[0-9]+\.[0-9]+$" | grep -v "^$CURRENT_TAG$" | head -1)
          if [ -n "$PREVIOUS_STABLE" ]; then
            echo "Previous stable release: $PREVIOUS_STABLE"
            echo "cliff_args=$PREVIOUS_STABLE..$CURRENT_TAG" >> $GITHUB_OUTPUT
            echo "range_description=Changes since $PREVIOUS_STABLE" >> $GITHUB_OUTPUT
          else
            echo "No previous stable release found, showing all changes"
            echo "cliff_args=--unreleased" >> $GITHUB_OUTPUT
            echo "range_description=All changes" >> $GITHUB_OUTPUT
          fi
        fi
      shell: bash

    - name: Generate Changelog
      uses: orhun/git-cliff-action@v4
      id: git-cliff
      with:
        config: cliff.toml        
        args: "--verbose ${{ steps.changelog-range.outputs.cliff_args }}"
      env:
        OUTPUT: CHANGES.md
        
    - name: Update Release Notes
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          
          // Get the current release
          const { data: release } = await github.rest.repos.getRelease({
            owner: context.repo.owner,
            repo: context.repo.repo,
            release_id: context.payload.release.id
          });
          
          // Read the generated changelog
          let changelog = '';
          try {
            changelog = fs.readFileSync('CHANGES.md', 'utf8');
            console.log('Generated changelog:', changelog);
          } catch (error) {
            console.log('Could not read CHANGES.md:', error.message);
            changelog = '## What\'s Changed\n\nChangelog generation failed. Please check the git-cliff configuration.';
          }
          
          // Generate GitHub's native release notes to get contributors with profile pictures
          let githubNotes = '';
          try {
            const { data: generatedNotes } = await github.rest.repos.generateReleaseNotes({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: release.tag_name,
              target_commitish: release.target_commitish || 'main'
            });
            githubNotes = generatedNotes.body;
            console.log('GitHub generated notes:', githubNotes);
          } catch (error) {
            console.log('Could not generate GitHub release notes:', error.message);
          }
          
          // Extract contributors section from GitHub's generated notes
          let contributorsSection = '';
          let fullChangelogSection = '';
          
          if (githubNotes) {
            // Extract "New Contributors" section
            const newContributorsMatch = githubNotes.match(/## New Contributors\n([\s\S]*?)(?=\n## |$)/);
            if (newContributorsMatch) {
              contributorsSection = '## New Contributors\n' + newContributorsMatch[1].trim();
            }
            
            // Extract "Full Changelog" section
            const fullChangelogMatch = githubNotes.match(/\*\*Full Changelog\*\*: .*/);
            if (fullChangelogMatch) {
              fullChangelogSection = fullChangelogMatch[0];
            }
          }
          
          // Build release body
          let releaseBody = '';
          
          // Add beta warning if this is a pre-release
          if (release.prerelease) {
            releaseBody += "**This is a beta release**\n\n";
            releaseBody += "This is a pre-release version intended for testing and feedback. It may contain bugs and is not recommended for the average user.\n\n";
            releaseBody += "Please report any issues you encounter to help us improve the final release.\n\n";
            releaseBody += "---\n\n";
          }
          
          // Add the changelog content
          releaseBody += changelog;
            // Add download information
          releaseBody += "\n\n## Downloads\n\n";
          releaseBody += "This release includes binaries for the following platforms:\n\n";
          releaseBody += "| Platform | Architecture | Binary File |\n";
          releaseBody += "|----------|--------------|-------------|\n";
          releaseBody += `| Windows | x64 | \`yomine-${release.tag_name}-windows-x64.exe\` |\n`;
          releaseBody += `| macOS (Universal) | Intel + Apple Silicon | \`yomine-${release.tag_name}-macos-universal\` |\n`;
          releaseBody += `| Linux | x64 | \`yomine-${release.tag_name}-linux-x64\` |\n\n`;
          releaseBody += "## Installation Instructions\n\n";
          releaseBody += "### Windows\n";
          releaseBody += "1. Download `yomine-${release.tag_name}-windows-x64.exe`\n";
          releaseBody += "2. Run the executable directly\n\n";
          releaseBody += "### macOS\n";
          releaseBody += "1. Download `yomine-${release.tag_name}-macos-universal`\n";
          releaseBody += "2. Make it executable: `chmod +x yomine-${release.tag_name}-macos-universal`\n";
          releaseBody += "3. Run the binary: `./yomine-${release.tag_name}-macos-universal`\n\n";
          releaseBody += "**⚠️ macOS Security Note:**\n";
          releaseBody += "If you get a security warning when first running the app:\n";
          releaseBody += "1. Go to **System Preferences → Security & Privacy**\n";
          releaseBody += "2. Click **\"Allow Anyway\"** next to the blocked app message\n";
          releaseBody += "3. Run the app again - it should now work normally\n\n";
          releaseBody += "This is normal for applications downloaded outside the Mac App Store.\n\n";
          releaseBody += "### Linux\n";
          releaseBody += "1. Download `yomine-${release.tag_name}-linux-x64`\n";
          releaseBody += "2. Make it executable: `chmod +x yomine-${release.tag_name}-linux-x64`\n";
          releaseBody += "3. Run the binary: `./yomine-${release.tag_name}-linux-x64`\n\n";
          releaseBody += "**Verification:** SHA256 checksums are available in `SHA256SUMS.txt`\n\n";
          
          // Update the release with generated notes
          await github.rest.repos.updateRelease({
            owner: context.repo.owner,
            repo: context.repo.repo,
            release_id: context.payload.release.id,
            body: releaseBody
          });
